%{
    #include <string>
    #include "AstNode.h"
    #include "ClassDeclaration.h"
    #include "CommonStatement.h"
    #include "Expression.h"
    #include "FunctionDeclaration.h"
    #include "Literal.h"
    #include "Statement.h"
    #include "StringExpression.h"
    #include "Type.h"
    #include "VariableDeclaration.h"
    #include "qwq_parser.hpp"
    //#include "qwq.hpp"

    // ä¿å­˜identifierçš„å…·ä½“åç§?
    #define SAVE_IDENTIFIER yylval.string = new std::string(yytext, yyleng)
    // ä¿å­˜æ•´æ•°å…·ä½“çš„å€?
    #define SAVE_INTEGER yylval.integer = std::stoll(std::string(yytext, yyleng))
    // ä¿å­˜å°æ•°å…·ä½“çš„å€?
    #define SAVE_REAL yylval.real = std::stod(std::string(yytext, yyleng))
    // ä¿å­˜boolå˜é‡å…·ä½“çš„å€?,ä¸éœ€è¦åœ¨æ­¤è¿›è¡Œåˆ¤æ–?
    //#define SAVE_BOOLEAN yylval.boolean = std::string(yytext, yyleng) == "true" ? true : false
    // ä¿å­˜å…³é”®å­—å¯¹åº”çš„toukenå€?
    #define SAVE_TOKEN(t) (yylval.token = t)
    // å­—ç¬¦ä¸²ä»¥åŠå­—ç¬¦çš„å€¼çš„ä¿å­˜åœ¨çŠ¶æ€?<STR>ä»¥åŠ<CHARACTER>ä¸­å·²ç»å®ç°äº†

    int yylcolumn = 1;

    std::string g_str;

%}

%option noyywrap yylineno

%x STR
%x CHARACTER

digit       [0-9]
integer     [+-]?{digit}+
real        [+-]?{digit}+\.{digit}+
letter      [a-zA-Z]
identifier  [{letter}_]?[{letter}{digit}_]+

%%

 /* å­—ç¬¦ä¸²ä»¥åŠå­—ç¬¦ï¼ˆéœ€è¦æ”¹è¿›ï¼‰*/
"\""        {
                g_str = "";
                BEGIN(STR);
            }
"'"         {
                g_str = "";
                BEGIN(CHARACTER);
            }
<STR>"\""   {
                BEGIN(INITIAL);
                yylval.string = new std::string(g_str);
                return TSTRING;
            }
<CHARACTER>"'"  {
                    BEGIN(INITIAL);
                    yylval.character = g_str[0];
                    return TCHAR;
                }
<STR>[^"]       {
                    g_str += std::string(yytext);
                }
<CHARACTER>[^'] {
                    g_str += std::string(yytext);
                }

 /* å…³é”®å­?(29ä¸ªå…³é”®å­—)
    æ§åˆ¶å…³é”®å­? */
"if"            return SAVE_TOKEN(TIF);
"else"          return SAVE_TOKEN(TELSE);
"elif"          return SAVE_TOKEN(TELIF);
"for"           return SAVE_TOKEN(TFOR);
"while"         return SAVE_TOKEN(TWHILE);
"this"          return SAVE_TOKEN(TTHIS);
"public"        return SAVE_TOKEN(TPUBLIC);
"private"       return SAVE_TOKEN(TPRIVATE);
"protected"     return SAVE_TOKEN(TPROTECTED);
"extends"       return SAVE_TOKEN(TEXTEND);
"def"           return SAVE_TOKEN(TDEF);
"class"         return SAVE_TOKEN(TCLASS);
"return"        return SAVE_TOKEN(TRETURN);
"break"         return SAVE_TOKEN(TBREAK);
"continue"      return SAVE_TOKEN(TCONTINUE);
"in"            return SAVE_TOKEN(TIN);
 /* ç±»å‹å…³é”®å­? */
"int"           return SAVE_TOKEN(TINTTK);
"bool"          return SAVE_TOKEN(TBOOLTK);
"double"        return SAVE_TOKEN(TDOUBLETK);
"char"          return SAVE_TOKEN(TCHARTK);
"string"        return SAVE_TOKEN(TSTRTK);
"array"         return SAVE_TOKEN(TARRTK);
 /* æ¨¡æ¿ */
"template"      return SAVE_TOKEN(TTEMP);
"typename"      return SAVE_TOKEN(TTYNAME);
 /* å­—ç¬¦ä¸²æ“ä½? */
"substr"        return SAVE_TOKEN(TSUBS);
"reverse"       return SAVE_TOKEN(TREVS);
"title"         return SAVE_TOKEN(TTITLES);
"uppercase"     return SAVE_TOKEN(TUPS);
"lowercase"     return SAVE_TOKEN(TLOWS);


 /* è¿ç®—ç¬? */
 /* ç®—æ•°è¿ç®—ç¬? */
"**"            return SAVE_TOKEN(TPOWER);
"//"            return SAVE_TOKEN(TEDIV);
"++"            return SAVE_TOKEN(TSADD);
"--"            return SAVE_TOKEN(TSSUB);
"+"             return SAVE_TOKEN(TADD);
"-"             return SAVE_TOKEN(TSUB);
"*"             return SAVE_TOKEN(TMUL);
"/"             return SAVE_TOKEN(TDIV);
"%"             return SAVE_TOKEN(TMOD);
 /* é€»è¾‘è¿ç®—ç¬? */
"||"            return SAVE_TOKEN(TOR);
"&&"            return SAVE_TOKEN(TAND);
"!"             return SAVE_TOKEN(TNOT);
 /* å…³ç³»è¿ç®—ç¬? */
"=="            return SAVE_TOKEN(TEQ);
"!="            return SAVE_TOKEN(TNE);
">="            return SAVE_TOKEN(TGE);
"<="            return SAVE_TOKEN(TLE);
"<"             return SAVE_TOKEN(TLT);
">"             return SAVE_TOKEN(TGT);

 /* å…¶å®ƒè¿ç®—ç¬?(å‡½æ•°å®šä¹‰) */
"->"            return SAVE_TOKEN(TARROW);

 /* é™¤charã€stringä¹‹å¤–çš„å­—é¢é‡ */
"true"          {
                    yylval.boolean = 1;
                    return TBOOL;
                }
"false"         {
                    yylval.boolean = 0;
                    return TBOOL;
                }
{integer}       {
                    SAVE_INTEGER;
                    return TINTEGER;
                }
{real}          {
                    SAVE_REAL;
                    return TREAL;
                }
 /* ä¸éœ€è¦è¿›è¡Œé¢å¤–å¤„ç†çš„å­—ç¬¦ */
"("             return '(';
")"             return ')';
"["             return '[';
"]"             return ']';
"{"             return '{';
"}"             return '}';
"."             return '.';
","             return ',';
":"             return ':';
"="             return '=';
 /* éœ€è¦å¿½ç•¥çš„ç©ºç™½ç¬? */
[ \t\n\r]
 /* æ ‡è¯†ç¬? */
{identifier}    {
                    SAVE_IDENTIFIER;
                    return TIDENTIFIER;
                }
 /* å¯¹æœªçŸ¥å­—ç¬¦çš„å¤„ç† */
.               {
                    printf("line %d, len %d Unknown token %s !\n", yylineno, yyleng, yytext);
                    yyterminate();
                }
%%